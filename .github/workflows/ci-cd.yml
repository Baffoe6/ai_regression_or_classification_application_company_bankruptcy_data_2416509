name: CI/CD Pipeline for Bankruptcy Prediction

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  release:
    types: [ published ]

env:
  PYTHON_VERSION: '3.9'
  NODE_VERSION: '18'

jobs:
  # Job 1: Code Quality and Linting
  code-quality:
    runs-on: ubuntu-latest
    name: Code Quality Check
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install flake8 black isort mypy bandit safety
        pip install -r requirements.txt
        
    - name: Code formatting check (Black)
      run: black --check --diff src/ tests/ *.py
      
    - name: Import sorting check (isort)
      run: isort --check-only --diff src/ tests/ *.py
      
    - name: Linting (flake8)
      run: flake8 src/ tests/ *.py --max-line-length=88 --extend-ignore=E203,W503
      
    - name: Type checking (mypy)
      run: mypy src/ --ignore-missing-imports
      continue-on-error: true
      
    - name: Security scan (bandit)
      run: bandit -r src/ -f json -o bandit-report.json
      continue-on-error: true
      
    - name: Dependency vulnerability scan (safety)
      run: safety check --json --output safety-report.json
      continue-on-error: true
      
    - name: Upload security reports
      uses: actions/upload-artifact@v4
      with:
        name: security-reports
        path: |
          bandit-report.json
          safety-report.json

  # Job 2: Unit Testing
  test:
    runs-on: ubuntu-latest
    needs: code-quality
    strategy:
      matrix:
        python-version: ['3.8', '3.9', '3.10', '3.11']
        
    name: Test Python ${{ matrix.python-version }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python ${{ matrix.python-version }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ matrix.python-version }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ matrix.python-version }}-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-${{ matrix.python-version }}-
          ${{ runner.os }}-pip-
          
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install pytest pytest-cov pytest-xdist
        pip install -r requirements.txt
        
    - name: Create test data
      run: |
        # Create minimal test dataset if CompanyBankruptcyData.csv doesn't exist
        python -c "
        import pandas as pd
        import numpy as np
        np.random.seed(42)
        n_samples = 1000
        data = {f'X{i+1}': np.random.randn(n_samples) for i in range(95)}
        data['Bankrupt?'] = np.random.binomial(1, 0.1, n_samples)
        df = pd.DataFrame(data)
        df.to_csv('CompanyBankruptcyData.csv', index=False)
        print('Test dataset created')
        "
        
    - name: Run unit tests
      run: |
        pytest tests/ -v --cov=src --cov-report=xml --cov-report=html --cov-report=term
        
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage.xml
        flags: unittests
        name: codecov-umbrella
        fail_ci_if_error: false

  # Job 3: Integration Testing
  integration-test:
    runs-on: ubuntu-latest
    needs: test
    name: Integration Tests
    
    services:
      # Add any required services (e.g., databases)
      redis:
        image: redis:6
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        ports:
          - 6379:6379
          
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install httpx pytest-asyncio
        
    - name: Create test data
      run: |
        python -c "
        import pandas as pd
        import numpy as np
        np.random.seed(42)
        n_samples = 1000
        data = {f'X{i+1}': np.random.randn(n_samples) for i in range(95)}
        data['Bankrupt?'] = np.random.binomial(1, 0.1, n_samples)
        df = pd.DataFrame(data)
        df.to_csv('CompanyBankruptcyData.csv', index=False)
        "
        
    - name: Test API endpoints
      run: |
        # Start API in background
        python simple_api.py &
        API_PID=$!
        
        # Wait for API to start
        sleep 10
        
        # Test API endpoints
        python -c "
        import requests
        import time
        import sys
        
        def test_api():
            base_url = 'http://localhost:8000'
            try:
                # Test health endpoint
                response = requests.get(f'{base_url}/health', timeout=5)
                assert response.status_code == 200
                print('✅ Health check passed')
                
                # Test features endpoint
                response = requests.get(f'{base_url}/features', timeout=5)
                assert response.status_code == 200
                print('✅ Features endpoint passed')
                
                # Test sample prediction
                response = requests.post(f'{base_url}/predict/sample', timeout=10)
                assert response.status_code == 200
                data = response.json()
                assert 'prediction' in data
                assert 'probability' in data
                print('✅ Sample prediction passed')
                
                return True
            except Exception as e:
                print(f'❌ API test failed: {e}')
                return False
        
        # Retry logic for API startup
        for i in range(30):
            try:
                if test_api():
                    break
            except:
                time.sleep(2)
                if i == 29:
                    sys.exit(1)
        "
        
        # Clean up
        kill $API_PID

  # Job 4: Build Docker Image
  build:
    runs-on: ubuntu-latest
    needs: [test, integration-test]
    name: Build Docker Image
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Create test data for Docker build
      run: |
        python -c "
        import pandas as pd
        import numpy as np
        np.random.seed(42)
        n_samples = 1000
        data = {f'X{i+1}': np.random.randn(n_samples) for i in range(95)}
        data['Bankrupt?'] = np.random.binomial(1, 0.1, n_samples)
        df = pd.DataFrame(data)
        df.to_csv('CompanyBankruptcyData.csv', index=False)
        "
        
    - name: Build Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: false
        tags: bankruptcy-prediction:${{ github.sha }}
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Test Docker image
      run: |
        # Run container in background
        docker run -d -p 8000:8000 --name test-container bankruptcy-prediction:${{ github.sha }}
        
        # Wait for container to start
        sleep 30
        
        # Test the containerized API
        curl -f http://localhost:8000/health || exit 1
        
        # Clean up
        docker stop test-container
        docker rm test-container

  # Job 5: Security Scanning
  security-scan:
    runs-on: ubuntu-latest
    needs: build
    name: Security Scanning
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Run Trivy vulnerability scanner
      uses: aquasecurity/trivy-action@master
      with:
        image-ref: bankruptcy-prediction:${{ github.sha }}
        format: 'sarif'
        output: 'trivy-results.sarif'
        
    - name: Upload Trivy scan results to GitHub Security tab
      uses: github/codeql-action/upload-sarif@v3
      with:
        sarif_file: 'trivy-results.sarif'

  # Job 6: Deploy to Staging (only on develop branch)
  deploy-staging:
    runs-on: ubuntu-latest
    needs: [build, security-scan]
    if: github.ref == 'refs/heads/develop'
    name: Deploy to Staging
    environment: staging
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/bankruptcy-prediction:staging
          ${{ secrets.DOCKER_USERNAME }}/bankruptcy-prediction:${{ github.sha }}
          
    - name: Deploy to staging environment
      run: |
        echo "Deploying to staging environment..."
        # Add your staging deployment commands here
        # Example: kubectl apply -f k8s/staging/
        # Example: helm upgrade --install bankruptcy-prediction ./helm-chart --namespace staging

  # Job 7: Deploy to Production (only on main branch and releases)
  deploy-production:
    runs-on: ubuntu-latest
    needs: [build, security-scan]
    if: github.ref == 'refs/heads/main' || github.event_name == 'release'
    name: Deploy to Production
    environment: production
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Login to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}
        
    - name: Extract version
      id: extract_version
      run: |
        if [[ "${{ github.event_name }}" == "release" ]]; then
          echo "VERSION=${{ github.event.release.tag_name }}" >> $GITHUB_OUTPUT
        else
          echo "VERSION=latest" >> $GITHUB_OUTPUT
        fi
        
    - name: Build and push Docker image
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true
        tags: |
          ${{ secrets.DOCKER_USERNAME }}/bankruptcy-prediction:${{ steps.extract_version.outputs.VERSION }}
          ${{ secrets.DOCKER_USERNAME }}/bankruptcy-prediction:latest
          
    - name: Deploy to production environment
      run: |
        echo "Deploying to production environment..."
        # Add your production deployment commands here
        # Example: kubectl apply -f k8s/production/
        # Example: helm upgrade --install bankruptcy-prediction ./helm-chart --namespace production

  # Job 8: Performance Testing (only on main branch)
  performance-test:
    runs-on: ubuntu-latest
    needs: deploy-production
    if: github.ref == 'refs/heads/main'
    name: Performance Testing
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install k6
      run: |
        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys C5AD17C747E3415A3642D57D77C6C491D6AC1D69
        echo "deb https://dl.k6.io/deb stable main" | sudo tee /etc/apt/sources.list.d/k6.list
        sudo apt-get update
        sudo apt-get install k6
        
    - name: Run performance tests
      run: |
        # Create k6 performance test script
        cat > performance-test.js << 'EOF'
        import http from 'k6/http';
        import { check, sleep } from 'k6';

        export let options = {
          stages: [
            { duration: '2m', target: 10 }, // Ramp up to 10 users
            { duration: '5m', target: 10 }, // Stay at 10 users
            { duration: '2m', target: 0 },  // Ramp down
          ],
        };

        export default function() {
          let response = http.get('http://localhost:8000/health');
          check(response, {
            'status is 200': (r) => r.status === 200,
            'response time < 500ms': (r) => r.timings.duration < 500,
          });
          
          response = http.post('http://localhost:8000/predict/sample');
          check(response, {
            'prediction status is 200': (r) => r.status === 200,
            'prediction time < 2000ms': (r) => r.timings.duration < 2000,
          });
          
          sleep(1);
        }
        EOF
        
        # Run performance test
        k6 run performance-test.js

  # Job 9: Notification
  notify:
    runs-on: ubuntu-latest
    needs: [deploy-production, performance-test]
    if: always()
    name: Notification
    
    steps:
    - name: Notify on success
      if: needs.deploy-production.result == 'success'
      run: |
        echo "✅ Deployment successful!"
        # Add notification logic (Slack, Teams, Email, etc.)
        
    - name: Notify on failure
      if: needs.deploy-production.result == 'failure' || needs.performance-test.result == 'failure'
      run: |
        echo "❌ Deployment or tests failed!"
        # Add failure notification logic